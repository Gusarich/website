<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>FKQA Benchmark</title>
        <meta
            name="description"
            content="A benchmark consisting of 100 short, factual questions derived from Wikipedia articles, covering a diverse range of random topics."
        />
        <link rel="stylesheet" href="../../styles.css" />
        <script>
            // Prevent flash of light mode
            (function() {
                const savedTheme = localStorage.getItem('theme');
                const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                
                if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
                    document.documentElement.classList.add('dark-mode');
                }
            })();
        </script>
        <script src="../../blog.js" defer></script>

        <link rel="canonical" href="https://gusarich.com/benchmarks/fkqa/" />

        <meta property="og:type" content="article" />
        <meta property="og:title" content="FKQA Benchmark" />
        <meta
            property="og:description"
            content="A benchmark consisting of 100 short, factual questions derived from Wikipedia articles, covering a diverse range of random topics."
        />
        <meta
            property="og:url"
            content="https://gusarich.com/benchmarks/fkqa/"
        />
        <meta
            property="og:image"
            content="https://gusarich.com/benchmarks/fkqa/preview.jpg"
        />
        <meta property="og:image:alt" content="FKQA Benchmark" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="630" />
        <meta property="og:locale" content="en_GB" />
        <meta property="og:site_name" content="Daniil Sedov" />

        <meta
            property="article:published_time"
            content="2025-05-10T21:39:34+03:00"
        />
        <meta property="article:author" content="https://gusarich.com/" />

        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="FKQA Benchmark" />
        <meta
            name="twitter:description"
            content="A benchmark consisting of 100 short, factual questions derived from Wikipedia articles, covering a diverse range of random topics."
        />
        <meta
            name="twitter:image"
            content="https://gusarich.com/benchmarks/fkqa/preview.jpg"
        />

        <script
            defer
            data-domain="gusarich.com"
            src="https://thanks.gusarich.com/js/script.hash.outbound-links.js"
        ></script>
        <script>
            window.plausible =
                window.plausible ||
                function () {
                    (window.plausible.q = window.plausible.q || []).push(
                        arguments
                    );
                };
        </script>
    </head>
    <body class="fkqa-benchmark">
        <div class="page-content">
            <header>
                <div class="container">
                    <h1>FKQA Benchmark</h1>
                </div>
            </header>
            <main>
                <div class="container">
                    <section class="benchmark-description">
                        <p>
                            <strong>FKQA</strong> is a benchmark consisting of
                            100 short, factual questions derived from Wikipedia
                            articles, covering a diverse range of random topics
                            without a specific focus on STEM, math, or coding.
                        </p>
                        <p>
                            <strong>FKQA-Hard</strong> is a more challenging
                            version of this benchmark.
                        </p>
                        <p>
                            Model responses are evaluated by an LLM-as-a-judge
                            setup, utilizing Gemini 2.5 Pro, which rigorously
                            scores each answer according to detailed rules
                            provided in a structured prompt, including the
                            original article, question, and answer context.
                        </p>
                        <p>
                            <a
                                href="#"
                                id="toggle-details"
                                class="details-toggle"
                                >Read more</a
                            >
                        </p>
                        <div id="details-section" class="details-section">
                            <p>The scoring uses six criteria:</p>
                            <ul>
                                <li>
                                    <strong>Faithfulness</strong>: accuracy and
                                    alignment with the provided article
                                </li>
                                <li>
                                    <strong>Relevance</strong>: directness in
                                    answering the exact question asked
                                </li>
                                <li>
                                    <strong>Completeness</strong>: addressing
                                    all parts of the question thoroughly
                                </li>
                                <li>
                                    <strong>Clarity</strong>: ease of
                                    understanding and grammatical correctness
                                </li>
                                <li>
                                    <strong>Conciseness</strong>: lack of
                                    unnecessary detail or repetition
                                </li>
                                <li>
                                    <strong>Self-Containedness</strong>:
                                    understandability without needing additional
                                    context
                                </li>
                            </ul>
                            <p>
                                An overall weighted score (0â€“100) emphasizes
                                Faithfulness (45%), followed by Relevance (20%),
                                Completeness (18%), Clarity (7%), Conciseness
                                (7%), and Self-Containedness (3%), highlighting
                                models' capabilities in reliably handling
                                general factual queries.
                            </p>
                            <p>
                                Four additional metrics provide deeper insights:
                            </p>
                            <ul>
                                <li>
                                    <strong>0% Hallucination</strong>:
                                    percentage of responses achieving 100%
                                    Faithfulness
                                </li>
                                <li>
                                    <strong>Rejection Rate</strong>: percentage
                                    of answers where the model explicitly
                                    declined to answer (e.g., "I don't know")
                                </li>
                                <li>
                                    <strong>Calibration</strong>: relative
                                    increase in Faithfulness after excluding
                                    rejections, indicating how effectively
                                    models abstain when uncertain
                                </li>
                                <li>
                                    An
                                    <strong>"Exclude Rejections"</strong>
                                    checkbox allows recalculating scores by
                                    excluding responses marked as rejections.
                                    This highlights how accurately models
                                    recognize when they do or do not have
                                    sufficient information
                                </li>
                            </ul>
                            <p>
                                The <strong>FKQA-Hard</strong> benchmark also
                                consists of 100 questions, but these were
                                specifically selected from a pool of 3000
                                FKQA-level questions, representing approximately
                                the top 3% most challenging questions from the
                                original FKQA dataset.
                            </p>
                            <p>
                                Additionally, search-powered models like Sonar
                                Pro and GPT-4o Search Preview were also
                                evaluated. However, comparing these directly to
                                models without web access is not advisable.
                                Filters are available in the results table to
                                include or exclude models based on their
                                web-search capabilities.
                            </p>
                            <p>
                                A detailed blog post describing the methodology
                                and insights found during benchmarking is coming
                                soon on
                                <a href="/#blog">my blog</a>.
                            </p>
                        </div>
                    </section>
                </div>
                <!-- Switch for Standard/Hard and Filters -->
                <div class="benchmark-controls">
                    <div class="benchmark-switch-section">
                        <div class="benchmark-mode-switches">
                            <button id="standard-btn" class="switch-btn active">
                                FKQA
                            </button>
                            <button id="hard-btn" class="switch-btn">
                                FKQA-Hard
                            </button>
                        </div>

                        <div class="filter-controls">
                            <div class="filter-group">
                                <label class="filter-item">
                                    <input type="checkbox" id="filter-search" />
                                    <span>Search-powered</span>
                                </label>
                                <label class="filter-item">
                                    <input
                                        type="checkbox"
                                        id="filter-nonsearch"
                                        checked
                                    />
                                    <span>Non-search</span>
                                </label>
                                <label class="filter-item">
                                    <input
                                        type="checkbox"
                                        id="exclude-rejections"
                                    />
                                    <span>Exclude Rejections</span>
                                </label>
                            </div>

                            <div class="organization-filter">
                                <span>Organization:</span>
                                <select id="organization-filter">
                                    <option value="all">
                                        All Organizations
                                    </option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="table-responsive">
                    <table id="leaderboard" class="benchmark-table">
                        <thead>
                            <tr id="header-row"></tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </main>
            <footer>
                <p>Happy to have you here!</p>
            </footer>
        </div>
        <script>
            const METRICS = [
                'Faithfulness',
                'Relevance',
                'Completeness',
                'Clarity',
                'Conciseness',
                'Self-Containedness',
            ];

            let currentData = [];
            const sortDir = {};
            let lastSortedIndex = null;
            let currentMode = 'standard'; // 'standard' or 'hard'
            let searchModels = [];
            let filterSearch = true;
            let filterNonSearch = true;
            let excludeRejections = false;
            let organizations = {};
            let selectedOrganization = 'all';

            async function fetchSearchModels() {
                const res = await fetch('search_models.json');
                return res.json();
            }

            async function fetchOrganizations() {
                const res = await fetch('organizations.json');
                return res.json();
            }

            async function fetchQuantizedModels() {
                try {
                    const res = await fetch('quantizations.json');
                    const quantizations = await res.json();

                    // Extract all quantization types to match against model names
                    const quantizationPatterns = [];
                    Object.values(quantizations).forEach((variants) => {
                        variants.forEach((variant) => {
                            // Extract the quantization part (e.g., "Q4_K_M", "Q6_K", etc.)
                            const quantType =
                                variant.quantization_type.toUpperCase();
                            quantizationPatterns.push(quantType);
                        });
                    });

                    return quantizationPatterns;
                } catch (error) {
                    console.error('Error loading quantizations:', error);
                    return [];
                }
            }

            async function fetchData(mode = 'standard') {
                const dataFile =
                    mode === 'hard' ? 'fkqa-hard.json' : 'fkqa.json';
                const [dataRes, pricesRes, quantizationPatterns] =
                    await Promise.all([
                        fetch(dataFile),
                        fetch('prices.json'),
                        fetchQuantizedModels(),
                    ]);
                const data = await dataRes.json();
                const prices = await pricesRes.json();

                // Filter out quantized models by checking if model name contains quantization patterns
                const filteredData = data.filter((item) => {
                    const modelName = item.model.toUpperCase();
                    return !quantizationPatterns.some((pattern) =>
                        modelName.includes(pattern)
                    );
                });

                filteredData.forEach((item) => {
                    if (prices[item.model] !== undefined) {
                        item.price = prices[item.model];
                    }
                });
                return filteredData;
            }

            function isSearchModel(modelName) {
                // Safety check to ensure searchModels is initialized
                if (!Array.isArray(searchModels)) return false;
                return searchModels.includes(modelName);
            }

            function applyFilters(data) {
                return data.filter((item) => {
                    const isSearch = isSearchModel(item.model);

                    // Search/Non-search filter
                    if (!filterSearch && !filterNonSearch) return false;
                    if (!filterSearch && isSearch) return false;
                    if (!filterNonSearch && !isSearch) return false;

                    // Organization filter
                    if (selectedOrganization !== 'all') {
                        const organizationModels =
                            organizations[selectedOrganization];
                        if (
                            !organizationModels ||
                            !organizationModels.includes(item.model)
                        ) {
                            return false;
                        }
                    }

                    return true;
                });
            }

            function loadAndBuild(mode) {
                fetchData(mode).then((data) => {
                    currentData = data; // Ensure currentData is set before building
                    buildTable(data);
                });
            }

            function populateOrganizationDropdown(data) {
                const orgSet = new Set();

                // Find which organizations are present in the current data
                data.forEach((item) => {
                    for (const [org, models] of Object.entries(organizations)) {
                        if (models.includes(item.model)) {
                            orgSet.add(org);
                            break;
                        }
                    }
                });

                const select = document.getElementById('organization-filter');
                // Clear existing options except "All"
                select.innerHTML =
                    '<option value="all">All Organizations</option>';

                // Sort organizations alphabetically
                const sortedOrgs = Array.from(orgSet).sort();
                sortedOrgs.forEach((org) => {
                    const option = document.createElement('option');
                    option.value = org;
                    option.textContent = org;
                    select.appendChild(option);
                });
            }

            // Switch button and filter logic
            document.addEventListener('DOMContentLoaded', async function () {
                try {
                    searchModels = await fetchSearchModels();
                    organizations = await fetchOrganizations();
                } catch (error) {
                    console.error('Error loading models/organizations:', error);
                    searchModels = [];
                    organizations = {};
                }

                const standardBtn = document.getElementById('standard-btn');
                const hardBtn = document.getElementById('hard-btn');
                const filterSearchBox =
                    document.getElementById('filter-search');
                const filterNonSearchBox =
                    document.getElementById('filter-nonsearch');
                const excludeRejectionsBox =
                    document.getElementById('exclude-rejections');
                const organizationSelect = document.getElementById(
                    'organization-filter'
                );

                // Explicitly set initial checkbox states
                filterSearchBox.checked = filterSearch;
                filterNonSearchBox.checked = filterNonSearch;
                excludeRejectionsBox.checked = excludeRejections;

                function setActive(mode) {
                    currentMode = mode;
                    standardBtn.classList.toggle('active', mode === 'standard');
                    hardBtn.classList.toggle('active', mode === 'hard');
                }
                standardBtn.addEventListener('click', function () {
                    if (currentMode !== 'standard') {
                        setActive('standard');
                        loadAndBuild('standard');
                    }
                });
                hardBtn.addEventListener('click', function () {
                    if (currentMode !== 'hard') {
                        setActive('hard');
                        loadAndBuild('hard');
                    }
                });
                filterSearchBox.addEventListener('change', function () {
                    filterSearch = filterSearchBox.checked;
                    buildTable(currentData);
                });
                filterNonSearchBox.addEventListener('change', function () {
                    filterNonSearch = filterNonSearchBox.checked;
                    buildTable(currentData);
                });
                excludeRejectionsBox.addEventListener('change', function () {
                    excludeRejections = excludeRejectionsBox.checked;
                    buildTable(currentData);
                });
                organizationSelect.addEventListener('change', function () {
                    selectedOrganization = organizationSelect.value;
                    buildTable(currentData);
                });
                setActive('standard');

                // Ensure we load the data after search models are loaded
                fetchData('standard').then((data) => {
                    currentData = data;
                    populateOrganizationDropdown(data);
                    buildTable(data);
                });
            });

            function buildTable(data) {
                currentData = data;

                // Calculate global rankings based on overall score (unfiltered)
                const globalRankedData = [...data].sort((a, b) => {
                    const dataSourceA = excludeRejections
                        ? a.without_rejections
                        : a.all;
                    const dataSourceB = excludeRejections
                        ? b.without_rejections
                        : b.all;
                    return dataSourceB.overall - dataSourceA.overall;
                });

                // Assign global ranks and initialize currentSortRank
                globalRankedData.forEach((item, index) => {
                    item.globalRank = index + 1;
                    item.currentSortRank = index + 1; // Initialize with overall ranking
                });

                const filtered = applyFilters(data);

                const headerRow = document.getElementById('header-row');
                headerRow.innerHTML = '';

                const columns = [
                    '#',
                    'Model',
                    'Overall',
                    '$/req',
                    'Rejection Rate',
                    'Calibration',
                    '0% Hallucination',
                    ...METRICS,
                ];
                columns.forEach((h, i) => {
                    const th = document.createElement('th');
                    if (i > 1) {
                        th.classList.add('sortable');
                        th.addEventListener('click', () => sortTable(i));
                        th.appendChild(document.createTextNode(h));
                        const arrow = document.createElement('span');
                        arrow.className = 'sort-arrow invisible';
                        th.appendChild(arrow);
                    } else {
                        th.textContent = h;
                    }
                    // Expand Model column
                    if (i === 1) th.style.minWidth = '180px';
                    // Center # column
                    if (i === 0) th.style.width = '48px';
                    headerRow.appendChild(th);
                });

                // Use previous sort if set, otherwise default to Overall
                let sortIndex = lastSortedIndex;
                if (typeof sortIndex !== 'number' || sortIndex < 2) {
                    sortIndex = columns.indexOf('Overall');
                }
                const direction =
                    sortDir[sortIndex] === undefined
                        ? false
                        : sortDir[sortIndex];
                sortTable(sortIndex, direction, filtered);
            }

            function renderBody(data) {
                const tbody = document.querySelector('#leaderboard tbody');
                tbody.innerHTML = '';
                data.forEach((item, idx) => {
                    const tr = document.createElement('tr');
                    const dataSource = excludeRejections
                        ? item.without_rejections
                        : item.all;

                    // Calculate faithfulness gain (Î”F) when rejections are excluded
                    let faithfulnessGain = 'N/A';
                    if (
                        item.rejection_rate > 0 &&
                        item.all.scores.Faithfulness > 0
                    ) {
                        const gainPercent =
                            (100 *
                                (item.without_rejections.scores.Faithfulness -
                                    item.all.scores.Faithfulness)) /
                            item.all.scores.Faithfulness;
                        faithfulnessGain =
                            gainPercent > 0
                                ? `+${gainPercent.toFixed(1)}%`
                                : `${gainPercent.toFixed(1)}%`;
                    }

                    const vals = [
                        item.currentSortRank.toString(), // Use overall rank in current sort
                        item.model,
                        dataSource.overall.toFixed(2),
                        item.price !== undefined
                            ? `$${item.price.toFixed(6)}`
                            : '',
                        `${item.rejection_rate.toFixed(0)}%`,
                        faithfulnessGain,
                        dataSource.perfect_faithfulness_pct !== undefined
                            ? `${dataSource.perfect_faithfulness_pct.toFixed(
                                  0
                              )}%`
                            : '',
                        ...METRICS.map((m) => dataSource.scores[m].toFixed(2)),
                    ];
                    vals.forEach((v, i) => {
                        const td = document.createElement('td');
                        td.textContent = v;
                        // Expand Model column
                        if (i === 1) td.style.minWidth = '180px';
                        // Center # column
                        if (i === 0) td.style.width = '48px';
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
            }

            function sortTable(colIndex, directionOverride, dataOverride) {
                // Disable sorting for # and Model columns
                if (colIndex === 0 || colIndex === 1) return;
                if (colIndex !== lastSortedIndex) {
                    sortDir[colIndex] = false; // new column: descending by default
                } else if (directionOverride === undefined) {
                    sortDir[colIndex] = !sortDir[colIndex]; // same column: toggle
                }
                lastSortedIndex = colIndex;

                const keyMap = [
                    '#',
                    'model',
                    'overall',
                    'price',
                    'rejection_rate',
                    'faithfulness_gain',
                    'perfect_faithfulness_pct',
                    ...METRICS,
                ];
                const key = keyMap[colIndex];

                // First, sort ALL data to get global rankings for current sort
                const allDataSorted = [...currentData].sort((a, b) => {
                    let valA, valB;
                    const dataSourceA = excludeRejections
                        ? a.without_rejections
                        : a.all;
                    const dataSourceB = excludeRejections
                        ? b.without_rejections
                        : b.all;

                    if (key === 'overall') {
                        valA = dataSourceA.overall;
                        valB = dataSourceB.overall;
                    } else if (key === 'price') {
                        valA = a.price;
                        valB = b.price;
                    } else if (key === 'rejection_rate') {
                        valA = a.rejection_rate;
                        valB = b.rejection_rate;
                    } else if (key === 'faithfulness_gain') {
                        // Calculate faithfulness gain for sorting
                        if (
                            a.rejection_rate > 0 &&
                            a.all.scores.Faithfulness > 0
                        ) {
                            valA =
                                (a.without_rejections.scores.Faithfulness -
                                    a.all.scores.Faithfulness) /
                                a.all.scores.Faithfulness;
                        } else {
                            valA = 0;
                        }
                        if (
                            b.rejection_rate > 0 &&
                            b.all.scores.Faithfulness > 0
                        ) {
                            valB =
                                (b.without_rejections.scores.Faithfulness -
                                    b.all.scores.Faithfulness) /
                                b.all.scores.Faithfulness;
                        } else {
                            valB = 0;
                        }
                    } else if (key === 'perfect_faithfulness_pct') {
                        valA = dataSourceA.perfect_faithfulness_pct;
                        valB = dataSourceB.perfect_faithfulness_pct;
                    } else {
                        valA = dataSourceA.scores[key];
                        valB = dataSourceB.scores[key];
                    }
                    return (
                        (valA < valB ? -1 : valA > valB ? 1 : 0) *
                        (sortDir[colIndex] ? 1 : -1)
                    );
                });

                // Assign global ranks based on current sort
                allDataSorted.forEach((item, index) => {
                    item.currentSortRank = index + 1;
                });

                // Then filter and sort the filtered data
                const filtered = dataOverride || applyFilters(currentData);
                const direction =
                    directionOverride !== undefined
                        ? directionOverride
                        : sortDir[colIndex];
                filtered.sort((a, b) => {
                    let valA, valB;
                    const dataSourceA = excludeRejections
                        ? a.without_rejections
                        : a.all;
                    const dataSourceB = excludeRejections
                        ? b.without_rejections
                        : b.all;

                    if (key === 'overall') {
                        valA = dataSourceA.overall;
                        valB = dataSourceB.overall;
                    } else if (key === 'price') {
                        valA = a.price;
                        valB = b.price;
                    } else if (key === 'rejection_rate') {
                        valA = a.rejection_rate;
                        valB = b.rejection_rate;
                    } else if (key === 'faithfulness_gain') {
                        // Calculate faithfulness gain for sorting
                        if (
                            a.rejection_rate > 0 &&
                            a.all.scores.Faithfulness > 0
                        ) {
                            valA =
                                (a.without_rejections.scores.Faithfulness -
                                    a.all.scores.Faithfulness) /
                                a.all.scores.Faithfulness;
                        } else {
                            valA = 0;
                        }
                        if (
                            b.rejection_rate > 0 &&
                            b.all.scores.Faithfulness > 0
                        ) {
                            valB =
                                (b.without_rejections.scores.Faithfulness -
                                    b.all.scores.Faithfulness) /
                                b.all.scores.Faithfulness;
                        } else {
                            valB = 0;
                        }
                    } else if (key === 'perfect_faithfulness_pct') {
                        valA = dataSourceA.perfect_faithfulness_pct;
                        valB = dataSourceB.perfect_faithfulness_pct;
                    } else {
                        valA = dataSourceA.scores[key];
                        valB = dataSourceB.scores[key];
                    }
                    return (
                        (valA < valB ? -1 : valA > valB ? 1 : 0) *
                        (direction ? 1 : -1)
                    );
                });

                renderBody(filtered);
                updateSortIndicators(colIndex);
            }

            function updateSortIndicators(activeIndex) {
                document.querySelectorAll('#header-row th').forEach((th, i) => {
                    const arrow = th.querySelector('.sort-arrow');
                    if (arrow) {
                        arrow.textContent = '';
                        arrow.classList.add('invisible');
                    }
                    th.classList.remove('sort-asc', 'sort-desc');
                    if (i === activeIndex && i > 1) {
                        th.classList.add(
                            sortDir[activeIndex] ? 'sort-asc' : 'sort-desc'
                        );
                        if (arrow) {
                            arrow.textContent = sortDir[activeIndex]
                                ? 'â–²'
                                : 'â–¼';
                            arrow.classList.remove('invisible');
                        }
                    }
                });
            }

            document.getElementById('details-section').style.display = 'none';
            const toggle = document.getElementById('toggle-details');
            const details = document.getElementById('details-section');
            toggle.addEventListener('click', function (e) {
                e.preventDefault();
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    toggle.textContent = 'Collapse';
                } else {
                    details.style.display = 'none';
                    toggle.textContent = 'Read more';
                }
            });
        </script>
        <style>
            .switch-btn {
                display: inline-block;
                padding: 10px 28px;
                margin: 0 8px;
                font-size: 1rem;
                border: 1.5px solid #b0b8c9;
                background: #f4f7fb;
                color: #234;
                border-radius: 8px;
                cursor: pointer;
                box-shadow: 0 2px 8px 0 rgba(30, 42, 80, 0.06);
                font-weight: 500;
                letter-spacing: 0.01em;
                outline: none;
                position: relative;
            }
            .switch-btn.active {
                background: linear-gradient(90deg, #2563eb 0%, #1e40af 100%);
                color: #fff;
                border-color: #2563eb;
                box-shadow: 0 4px 16px 0 rgba(37, 99, 235, 0.13);
                z-index: 1;
            }
            .switch-btn:not(.active):hover {
                background: #e6edfa;
                color: #1741a0;
                border-color: #2563eb;
            }
        </style>
    </body>
</html>
